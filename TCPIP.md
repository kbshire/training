# TCP/IP

1.TCP三次握手

![img](https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/7bc94edb74608af80fbb4de8ab9c1bd7.png) 

![image-20230322101541044](https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230322101541044.png)

![img](https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/11bd3c08694c9f869c3607fe32edb8ff.png) 

![image-20230322102027086](https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230322102027086.png) 



```
timewait
为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。
在这里，如果图中主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文。如果主机 1 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误。而重发fin一来一去正好两个MSL
让之前因为某些原因延迟到达路由器的报文消失，如果关闭的连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起
time-wait是从主机A收到FIN后发送ack开始计时的
从 TIME_WAIT 进入 CLOSED 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 CLOSED 状态。

timewait的危害
第一是内存资源占用
第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。
```

```
三次和四次
为了保证A发送的最后一个ACK报文段能够到达B。
没有数据传输，服务端的SYN和ACK报文可以一起发送，但是挥手时有数据传输,等待自己的数据传输完成后再ACK，ACK和FIN报文不能同时发送
```

```
为什么三次握不是两次握
一是双方都做好发送数据的准备工作，而且双方都知道对方已准备好；二是双方完成初始SN序列号的协商，双方的SN序列号在握手过程中被发送和确认。
如果把三次握手改成两次握手，可能发生死锁。两次握手的话，缺失了Client的二次确认ACK帧
如果确认应答SYN+ACK帧在传输中被丢失，Client没有收到，Client将不知道Server是否已准备好，也不知道Server的SN序列号，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，会一直等待Server的SYN+ACK确认应答帧。而Server在发出的数据帧后，一直没有收到对应的ACK确认后就会产生超时，重复发送同样的数据帧。这样就形成了死锁。
```

```
三次握手和四次挥手七个包丢了会怎么办
syn = 1丢了 计时器超时后重传第一个包(syn=1)
syn = 1, ack = 1丢了 重传第一个(syn=1)和第二个包(syn=1,ack=1)
ack = 1丢了 等待3秒、6秒、12秒后重新发送第二个(syn=1,ack=1)包
客户端fin = 1丢了 重传第一个包(fin=1)
服务端ack = 1丢了 重传第一个(fin=1)和第二个包(ack=1)
服务端fin = 1丢了 服务端重传第三个包(fin=1),client行为分类讨论，如果已经和别人建立了连接，那么回RST，如果没跑路，那么client将永远停留在这个状态(fin-wait)
客户端ack = 1丢了 服务端重传第三个包(fin=1),客户端等待Time-wait，即2MSL
```

```
连续收到三个ack咋办
当TCP源端收到3个相同的ACK确认时，即认为有数据包丢失，则源端重传丢失的数据包，而不必等待RTO(Retransmission Timeout)超时。
```

```
已经建立连接，client突然寄了
TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。
```

```
上面说了一堆参数，他们都在哪调
重传次数由/proc/sys/net/ipv4/tcp_syn_retries
第一次握手重传次数限制
/proc/sys/net/ipv4/tcp_syn_retries
第二次握手重传次数限制
/proc/sys/net/ipv4/tcp_synack_retries
数据包最大重传次数限制
/proc/sys/net/ipv4/tcp_retries2
```

```
滑动窗口
数据的传送过程中很可能出现接收方来不及接收的情况，这时就需要对发送方进行控制以免数据丢失。利用滑动窗口机制可以很方便地在TCP连接上对发送方的流量进行控制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。
TCP规定，即使设置为零窗口，也必须接收以下几种报文段
零窗口探测报文段
确认报文段
携带紧急数据的报文段
```

```
延迟计时器
存在这样一种情况：发送方接收到零窗口报文之后将发送窗口设置为0，停止发送数据。但等到接收方有足够缓存，发送了非零窗口大小的报文，但是这个报文中途丢失，那么发送方的发送窗口就一直为0导致死锁。
为此，TCP为每一个连接设有一个持续计时器(Persistence Timer)：当TCP连接的一方收到对方的零窗口通知时就启动持续计时器。若持续计时器时间到期，就发送一个零窗口探测报文段(携有1字节的数据)，那么收到这个报文段的一方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器；若窗口不是零，则死锁的僵局就可以打破了。
```

```
延迟ack
如果TCP对每个数据包都发送一个ACK确认，那么只是一个单独的数据包为了发送一个ACK代价比较高，所以TCP会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ACK，如果在延迟ACK定时器触发时候，发现ACK尚未发送，则立即单独发送；
如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ACK确认多个报文段。减少流量消耗。
```

```
拥塞控制
拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。
数据单方向传送，而另外一个方向只传送确认。
接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。
发送方的发送窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的一个，即发送窗口的上限值为Min[rwnd, cwnd]
当rwnd < cwnd时，是接收方的接收能力限制发送窗口的最大值
当cwnd < rwnd时，则是网络的拥塞限制发送窗口的最大值
```

```
慢启动
发送方维护一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，动态变化。通过逐渐增加cwnd的大小来探测可用的网络容量，防止连接开始时采用不合适的发送量导致网络拥塞。较好的方法是试探，从小到大逐渐增大发送端拥塞窗口的cwnd数值。
开始发送方先设置cwnd=1，发送第一个报文段M1，接收方接收到M1后，ACK返回给发送端，发送端将cwnd增加到2，接着发送方发送M2，再次接受到ACK后将cwnd增加到4...慢启动算法每经过一个传输轮次，拥塞窗口cwnd就加倍。
当rwnd足够大时，为防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量，慢开始门限ssthresh
当cwnd＜ssthresh，使用慢开始算法
当cwnd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
当cwnd＞ssthresh，使用拥塞避免算法
```

![image-20230322104713717](https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230322104713717.png) 

```
拥塞避免
TCP连接初始化，将拥塞窗口cwnd设置为1个报文段，即cwnd=1
执行慢开始算法，cwnd按指数规律增长，直到cwnd == ssthresh时，开始拥塞避免算法，cwnd按线性规律增长
当网络发生阻塞，把ssthresh值更新为拥塞前cwnd的一半(12=24/2)，cwnd重新设置为1，再按照(2)执行
让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍。这样拥塞窗口cwnd线性缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢地多。
无论慢启动开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(没收到ACK)，就把慢启动门限ssthresh设置为出现拥塞时的cwnd的一半。然后把拥塞窗口cwnd重新设置为1，执行慢启动算法。这样做的目的是能迅速的减少主机向网络中传输数据，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。拥塞窗口是按照线性的规律增长，比慢启动算法拥塞窗口增长快的多。
拥塞避免是由指数增长拉低到线性增长，降低出现拥塞的可能，并不是能完全避免网络拥塞
```

```
TCP包结构
URG

占1位，表示紧急指针字段有效。URG位指示报文段里的上层实体（数据）标记为“紧急”数据。当URG=1时，其后的紧急指针指示紧急数据在当前数据段中的位置(相对于当前序列号的字节偏移量)，TCP接收方必须通知上层实体。

ACK

占1位，置位ACK=1表示确认号字段有效；TCP协议规定，接建立后所有发送的报文的ACK必须为1；当ACK=0时，表示该数据段不包含确认信息。当ACK=1时，表示该报文段包括一个对已被成功接收报文段的确认序号Acknowledgment Number，该序号同时也是下一个报文的预期序号。

PSH

占1位，表示当前报文需要请求推（push）操作；当PSH=1时，接收方在收到数据后立即将数据交给上层，而不是直到整个缓冲区满。

RST

占1位，置位RST=1表示复位TCP连接；用于重置一个已经混乱的连接，也可用于拒绝一个无效的数据段或者拒绝一个连接请求。如果数据段被设置了RST位，说明报文发送方有问题发生。

SYN

占1位，在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1。 综合一下，SYN置1就表示这是一个连接请求或连接接受报文。

FIN

占1位，用于在释放TCP连接时，标识发送方比特流结束，用来释放一个连接。当 FIN = 1时，表明此报文的发送方的数据已经发送完毕，并要求释放连接。
```

![img](https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/9dbe51acdad6db2f4feef58c7a117226.png) 



```
封装与解封装
应用层，人机交互接口，接收用户输入
表示层，将接收到的数据翻译成二进制数组成的计算机语言，并对数据进行压缩和解压、数据加密和解密等工作
会话层，建立、管理、中止会话。
传输层，为每个数据封装 TCP或UDP 报文头部。 在头部有一个关键的字段信息——端口号，它用于标识上层的协议或应用程序，确保上层应用数据的正常通信。
网络层，上层数据被封装上新的报文头部——IP 头部。 在 IP 头部中有一个关键的字段信息——IP 地址，进行逻辑地址寻址
数据链路层，上层数据被封装一个 MAC 头部，其内部有一个关键的字段信息 ——MAC 地址，在 MAC 头部也同时封装着目标 MAC 地址和源 MAC 地址，进行硬件地址寻址、差错校验等功能。
在物理层，将这些二进制数字组成的比特流转换成电信号在网络中传输。

在物理层，首先将电信号转换成二进制数据，并将数据送至数据链路层
在数据链路层， 将查看目标 MAC 地址，判断其是否与自己的 MAC 地址吻合，并据此完成后续处理。如果 数据报文的目标 MAC 地址就是自己的 MAC 地址，数据的 MAC 头部将被“拆掉”，并将剩余 的数据送至上一层；如果目标 MAC 地址不是自己的 MAC 地址，对于终端设备来说，它将 会丢弃数据
在网络层与在数据链路层类似，目标 IP 地址将被核实是否与自己的 IP 地址相 同，从而确定是否送至上一层
到了传输层，首先要根据 TCP 头部判断数据段送往哪个应用层协议或应用程序，然后将之前被分组的数据段重组，再送往应用层
会话层，建立、管理、中止会话。
表示层，将接收到的二进制变为应用的数据，并对数据进行压缩和解压、数据加密和解密等工作
在应用层，这些数据将经历复杂的解码过程，以还原发送者所传输的原始信息。
```

```
osi/tcpip区别
OSI:							TCP/IP
应用层							应用层		
表示层			
会话层
传输层							传输层
网络层							网路层
数据链路层					  网络接口层
网络层

层数不同—-OSI为7层，TCP/IP为四层或五层
TCP/IP支持跨层封装；OSI不支持  跨层封装主要用于非终端设备间相互沟通的流量，非远距离；
TCP/IP仅仅支持IP网络协议;  OSI支持多种网络层协议（IP    IPX    APPLE  TALK    NOVELL   NSAP）
TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。
OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。
TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。
OSI 实现起来较困难；相反，TCP/IP作为一种简化的分层结构还是比较成功的。
```

